// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: pos_rpc.proto
#ifndef GRPC_pos_5frpc_2eproto__INCLUDED
#define GRPC_pos_5frpc_2eproto__INCLUDED

#include "pos_rpc.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace pos_rpc {

class Health final {
 public:
  static constexpr char const* service_full_name() {
    return "pos_rpc.Health";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::pos_rpc::HealthCheckResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::HealthCheckResponse>> AsyncCheck(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::HealthCheckResponse>>(AsyncCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::HealthCheckResponse>> PrepareAsyncCheck(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::HealthCheckResponse>>(PrepareAsyncCheckRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::HealthCheckResponse>* AsyncCheckRaw(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::HealthCheckResponse>* PrepareAsyncCheckRaw(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::pos_rpc::HealthCheckResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::HealthCheckResponse>> AsyncCheck(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::HealthCheckResponse>>(AsyncCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::HealthCheckResponse>> PrepareAsyncCheck(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::HealthCheckResponse>>(PrepareAsyncCheckRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::HealthCheckResponse>* AsyncCheckRaw(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::HealthCheckResponse>* PrepareAsyncCheckRaw(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Check_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Check(::grpc::ServerContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Check() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheck(::grpc::ServerContext* context, ::pos_rpc::HealthCheckRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::HealthCheckResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Check<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Check() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::HealthCheckRequest, ::pos_rpc::HealthCheckResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response) { return this->Check(context, request, response); }));}
    void SetMessageAllocatorFor_Check(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::HealthCheckRequest, ::pos_rpc::HealthCheckResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::HealthCheckRequest, ::pos_rpc::HealthCheckResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Check(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Check(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Check<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Check<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Check() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Check() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheck(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Check() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Check(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Check(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Check(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Check() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::HealthCheckRequest, ::pos_rpc::HealthCheckResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::HealthCheckRequest, ::pos_rpc::HealthCheckResponse>* streamer) {
                       return this->StreamedCheck(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheck(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::HealthCheckRequest,::pos_rpc::HealthCheckResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Check<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Check<Service > StreamedService;
};

// /////////////////////////////////////////////////////////////////////////////////
//
class PosManagement final {
 public:
  static constexpr char const* service_full_name() {
    return "pos_rpc.PosManagement";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status CreateArray(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest& request, ::pos_rpc::PosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> AsyncCreateArray(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(AsyncCreateArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> PrepareAsyncCreateArray(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(PrepareAsyncCreateArrayRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteArray(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest& request, ::pos_rpc::PosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> AsyncDeleteArray(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(AsyncDeleteArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> PrepareAsyncDeleteArray(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(PrepareAsyncDeleteArrayRaw(context, request, cq));
    }
    virtual ::grpc::Status CreateVolume(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest& request, ::pos_rpc::PosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> AsyncCreateVolume(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(AsyncCreateVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> PrepareAsyncCreateVolume(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(PrepareAsyncCreateVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteVolume(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest& request, ::pos_rpc::PosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> AsyncDeleteVolume(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(AsyncDeleteVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> PrepareAsyncDeleteVolume(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(PrepareAsyncDeleteVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status MountVolume(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest& request, ::pos_rpc::PosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> AsyncMountVolume(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(AsyncMountVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> PrepareAsyncMountVolume(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(PrepareAsyncMountVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status UnmountVolume(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest& request, ::pos_rpc::PosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> AsyncUnmountVolume(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(AsyncUnmountVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> PrepareAsyncUnmountVolume(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(PrepareAsyncUnmountVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::pos_rpc::PosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> AsyncUpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(AsyncUpdateVoluemMetaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> PrepareAsyncUpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(PrepareAsyncUpdateVoluemMetaRaw(context, request, cq));
    }
    virtual ::grpc::Status GetArrayList(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest& request, ::pos_rpc::ArrayListResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ArrayListResponse>> AsyncGetArrayList(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ArrayListResponse>>(AsyncGetArrayListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ArrayListResponse>> PrepareAsyncGetArrayList(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ArrayListResponse>>(PrepareAsyncGetArrayListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::pos_rpc::VolumeListResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::VolumeListResponse>> AsyncGetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::VolumeListResponse>>(AsyncGetVolumeListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::VolumeListResponse>> PrepareAsyncGetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::VolumeListResponse>>(PrepareAsyncGetVolumeListRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void CreateArray(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateArray(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateArray(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DeleteArray(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteArray(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteArray(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void CreateVolume(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateVolume(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateVolume(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DeleteVolume(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteVolume(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteVolume(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MountVolume(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MountVolume(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MountVolume(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void UnmountVolume(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnmountVolume(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnmountVolume(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetArrayList(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest* request, ::pos_rpc::ArrayListResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetArrayList(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest* request, ::pos_rpc::ArrayListResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetArrayList(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest* request, ::pos_rpc::ArrayListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* AsyncCreateArrayRaw(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* PrepareAsyncCreateArrayRaw(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* AsyncDeleteArrayRaw(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* PrepareAsyncDeleteArrayRaw(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* AsyncCreateVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* PrepareAsyncCreateVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* AsyncDeleteVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* PrepareAsyncDeleteVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* AsyncMountVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* PrepareAsyncMountVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* AsyncUnmountVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* PrepareAsyncUnmountVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* AsyncUpdateVoluemMetaRaw(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* PrepareAsyncUpdateVoluemMetaRaw(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ArrayListResponse>* AsyncGetArrayListRaw(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ArrayListResponse>* PrepareAsyncGetArrayListRaw(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::VolumeListResponse>* AsyncGetVolumeListRaw(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::VolumeListResponse>* PrepareAsyncGetVolumeListRaw(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status CreateArray(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest& request, ::pos_rpc::PosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> AsyncCreateArray(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(AsyncCreateArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> PrepareAsyncCreateArray(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(PrepareAsyncCreateArrayRaw(context, request, cq));
    }
    ::grpc::Status DeleteArray(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest& request, ::pos_rpc::PosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> AsyncDeleteArray(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(AsyncDeleteArrayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> PrepareAsyncDeleteArray(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(PrepareAsyncDeleteArrayRaw(context, request, cq));
    }
    ::grpc::Status CreateVolume(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest& request, ::pos_rpc::PosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> AsyncCreateVolume(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(AsyncCreateVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> PrepareAsyncCreateVolume(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(PrepareAsyncCreateVolumeRaw(context, request, cq));
    }
    ::grpc::Status DeleteVolume(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest& request, ::pos_rpc::PosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> AsyncDeleteVolume(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(AsyncDeleteVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> PrepareAsyncDeleteVolume(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(PrepareAsyncDeleteVolumeRaw(context, request, cq));
    }
    ::grpc::Status MountVolume(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest& request, ::pos_rpc::PosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> AsyncMountVolume(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(AsyncMountVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> PrepareAsyncMountVolume(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(PrepareAsyncMountVolumeRaw(context, request, cq));
    }
    ::grpc::Status UnmountVolume(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest& request, ::pos_rpc::PosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> AsyncUnmountVolume(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(AsyncUnmountVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> PrepareAsyncUnmountVolume(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(PrepareAsyncUnmountVolumeRaw(context, request, cq));
    }
    ::grpc::Status UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::pos_rpc::PosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> AsyncUpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(AsyncUpdateVoluemMetaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> PrepareAsyncUpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(PrepareAsyncUpdateVoluemMetaRaw(context, request, cq));
    }
    ::grpc::Status GetArrayList(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest& request, ::pos_rpc::ArrayListResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ArrayListResponse>> AsyncGetArrayList(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ArrayListResponse>>(AsyncGetArrayListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ArrayListResponse>> PrepareAsyncGetArrayList(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ArrayListResponse>>(PrepareAsyncGetArrayListRaw(context, request, cq));
    }
    ::grpc::Status GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::pos_rpc::VolumeListResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::VolumeListResponse>> AsyncGetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::VolumeListResponse>>(AsyncGetVolumeListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::VolumeListResponse>> PrepareAsyncGetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::VolumeListResponse>>(PrepareAsyncGetVolumeListRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void CreateArray(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateArray(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateArray(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteArray(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteArray(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteArray(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateVolume(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateVolume(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateVolume(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteVolume(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteVolume(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteVolume(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MountVolume(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MountVolume(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MountVolume(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnmountVolume(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnmountVolume(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnmountVolume(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetArrayList(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest* request, ::pos_rpc::ArrayListResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetArrayList(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest* request, ::pos_rpc::ArrayListResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetArrayList(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest* request, ::pos_rpc::ArrayListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* AsyncCreateArrayRaw(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* PrepareAsyncCreateArrayRaw(::grpc::ClientContext* context, const ::pos_rpc::CreateArrayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* AsyncDeleteArrayRaw(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* PrepareAsyncDeleteArrayRaw(::grpc::ClientContext* context, const ::pos_rpc::DeleteArrayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* AsyncCreateVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* PrepareAsyncCreateVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* AsyncDeleteVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* PrepareAsyncDeleteVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* AsyncMountVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* PrepareAsyncMountVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::MountVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* AsyncUnmountVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* PrepareAsyncUnmountVolumeRaw(::grpc::ClientContext* context, const ::pos_rpc::UnmountVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* AsyncUpdateVoluemMetaRaw(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* PrepareAsyncUpdateVoluemMetaRaw(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ArrayListResponse>* AsyncGetArrayListRaw(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ArrayListResponse>* PrepareAsyncGetArrayListRaw(::grpc::ClientContext* context, const ::pos_rpc::GetArrayListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::VolumeListResponse>* AsyncGetVolumeListRaw(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::VolumeListResponse>* PrepareAsyncGetVolumeListRaw(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateArray_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteArray_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_MountVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_UnmountVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateVoluemMeta_;
    const ::grpc::internal::RpcMethod rpcmethod_GetArrayList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVolumeList_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status CreateArray(::grpc::ServerContext* context, const ::pos_rpc::CreateArrayRequest* request, ::pos_rpc::PosResponse* response);
    virtual ::grpc::Status DeleteArray(::grpc::ServerContext* context, const ::pos_rpc::DeleteArrayRequest* request, ::pos_rpc::PosResponse* response);
    virtual ::grpc::Status CreateVolume(::grpc::ServerContext* context, const ::pos_rpc::CreateVolumeRequest* request, ::pos_rpc::PosResponse* response);
    virtual ::grpc::Status DeleteVolume(::grpc::ServerContext* context, const ::pos_rpc::DeleteVolumeRequest* request, ::pos_rpc::PosResponse* response);
    virtual ::grpc::Status MountVolume(::grpc::ServerContext* context, const ::pos_rpc::MountVolumeRequest* request, ::pos_rpc::PosResponse* response);
    virtual ::grpc::Status UnmountVolume(::grpc::ServerContext* context, const ::pos_rpc::UnmountVolumeRequest* request, ::pos_rpc::PosResponse* response);
    virtual ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response);
    virtual ::grpc::Status GetArrayList(::grpc::ServerContext* context, const ::pos_rpc::GetArrayListRequest* request, ::pos_rpc::ArrayListResponse* response);
    virtual ::grpc::Status GetVolumeList(::grpc::ServerContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateArray() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateArray(::grpc::ServerContext* /*context*/, const ::pos_rpc::CreateArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateArray(::grpc::ServerContext* context, ::pos_rpc::CreateArrayRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::PosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteArray() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_DeleteArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteArray(::grpc::ServerContext* /*context*/, const ::pos_rpc::DeleteArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteArray(::grpc::ServerContext* context, ::pos_rpc::DeleteArrayRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::PosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateVolume() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_CreateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::CreateVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateVolume(::grpc::ServerContext* context, ::pos_rpc::CreateVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::PosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteVolume() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_DeleteVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::DeleteVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteVolume(::grpc::ServerContext* context, ::pos_rpc::DeleteVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::PosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MountVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MountVolume() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_MountVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MountVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::MountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMountVolume(::grpc::ServerContext* context, ::pos_rpc::MountVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::PosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnmountVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnmountVolume() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_UnmountVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnmountVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::UnmountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnmountVolume(::grpc::ServerContext* context, ::pos_rpc::UnmountVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::PosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateVoluemMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateVoluemMeta() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_UpdateVoluemMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateVoluemMeta(::grpc::ServerContext* context, ::pos_rpc::UpdateVoluemMetaRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::PosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetArrayList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetArrayList() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetArrayList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArrayList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetArrayListRequest* /*request*/, ::pos_rpc::ArrayListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetArrayList(::grpc::ServerContext* context, ::pos_rpc::GetArrayListRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::ArrayListResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVolumeList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVolumeList() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetVolumeList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolumeList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVolumeList(::grpc::ServerContext* context, ::pos_rpc::GetVolumeListRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::VolumeListResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateArray<WithAsyncMethod_DeleteArray<WithAsyncMethod_CreateVolume<WithAsyncMethod_DeleteVolume<WithAsyncMethod_MountVolume<WithAsyncMethod_UnmountVolume<WithAsyncMethod_UpdateVoluemMeta<WithAsyncMethod_GetArrayList<WithAsyncMethod_GetVolumeList<Service > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::CreateArrayRequest, ::pos_rpc::PosResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::CreateArrayRequest* request, ::pos_rpc::PosResponse* response) { return this->CreateArray(context, request, response); }));}
    void SetMessageAllocatorFor_CreateArray(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::CreateArrayRequest, ::pos_rpc::PosResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::CreateArrayRequest, ::pos_rpc::PosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateArray(::grpc::ServerContext* /*context*/, const ::pos_rpc::CreateArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateArray(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::CreateArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::CreateArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::DeleteArrayRequest, ::pos_rpc::PosResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::DeleteArrayRequest* request, ::pos_rpc::PosResponse* response) { return this->DeleteArray(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteArray(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::DeleteArrayRequest, ::pos_rpc::PosResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::DeleteArrayRequest, ::pos_rpc::PosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteArray(::grpc::ServerContext* /*context*/, const ::pos_rpc::DeleteArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteArray(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::DeleteArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::DeleteArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::CreateVolumeRequest, ::pos_rpc::PosResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::CreateVolumeRequest* request, ::pos_rpc::PosResponse* response) { return this->CreateVolume(context, request, response); }));}
    void SetMessageAllocatorFor_CreateVolume(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::CreateVolumeRequest, ::pos_rpc::PosResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::CreateVolumeRequest, ::pos_rpc::PosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::CreateVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::CreateVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::CreateVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::DeleteVolumeRequest, ::pos_rpc::PosResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::DeleteVolumeRequest* request, ::pos_rpc::PosResponse* response) { return this->DeleteVolume(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteVolume(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::DeleteVolumeRequest, ::pos_rpc::PosResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::DeleteVolumeRequest, ::pos_rpc::PosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::DeleteVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::DeleteVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::DeleteVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MountVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MountVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::MountVolumeRequest, ::pos_rpc::PosResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::MountVolumeRequest* request, ::pos_rpc::PosResponse* response) { return this->MountVolume(context, request, response); }));}
    void SetMessageAllocatorFor_MountVolume(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::MountVolumeRequest, ::pos_rpc::PosResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::MountVolumeRequest, ::pos_rpc::PosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MountVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MountVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::MountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MountVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::MountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MountVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::MountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnmountVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnmountVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::UnmountVolumeRequest, ::pos_rpc::PosResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::UnmountVolumeRequest* request, ::pos_rpc::PosResponse* response) { return this->UnmountVolume(context, request, response); }));}
    void SetMessageAllocatorFor_UnmountVolume(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::UnmountVolumeRequest, ::pos_rpc::PosResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::UnmountVolumeRequest, ::pos_rpc::PosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnmountVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnmountVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::UnmountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnmountVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::UnmountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnmountVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::UnmountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateVoluemMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateVoluemMeta() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::UpdateVoluemMetaRequest, ::pos_rpc::PosResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response) { return this->UpdateVoluemMeta(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateVoluemMeta(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::UpdateVoluemMetaRequest, ::pos_rpc::PosResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::UpdateVoluemMetaRequest, ::pos_rpc::PosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateVoluemMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateVoluemMeta(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateVoluemMeta(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetArrayList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetArrayList() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::GetArrayListRequest, ::pos_rpc::ArrayListResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::GetArrayListRequest* request, ::pos_rpc::ArrayListResponse* response) { return this->GetArrayList(context, request, response); }));}
    void SetMessageAllocatorFor_GetArrayList(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::GetArrayListRequest, ::pos_rpc::ArrayListResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::GetArrayListRequest, ::pos_rpc::ArrayListResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetArrayList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArrayList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetArrayListRequest* /*request*/, ::pos_rpc::ArrayListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetArrayList(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::GetArrayListRequest* /*request*/, ::pos_rpc::ArrayListResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetArrayList(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::GetArrayListRequest* /*request*/, ::pos_rpc::ArrayListResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVolumeList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetVolumeList() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::GetVolumeListRequest, ::pos_rpc::VolumeListResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response) { return this->GetVolumeList(context, request, response); }));}
    void SetMessageAllocatorFor_GetVolumeList(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::GetVolumeListRequest, ::pos_rpc::VolumeListResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::GetVolumeListRequest, ::pos_rpc::VolumeListResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetVolumeList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolumeList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVolumeList(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVolumeList(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_CreateArray<ExperimentalWithCallbackMethod_DeleteArray<ExperimentalWithCallbackMethod_CreateVolume<ExperimentalWithCallbackMethod_DeleteVolume<ExperimentalWithCallbackMethod_MountVolume<ExperimentalWithCallbackMethod_UnmountVolume<ExperimentalWithCallbackMethod_UpdateVoluemMeta<ExperimentalWithCallbackMethod_GetArrayList<ExperimentalWithCallbackMethod_GetVolumeList<Service > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_CreateArray<ExperimentalWithCallbackMethod_DeleteArray<ExperimentalWithCallbackMethod_CreateVolume<ExperimentalWithCallbackMethod_DeleteVolume<ExperimentalWithCallbackMethod_MountVolume<ExperimentalWithCallbackMethod_UnmountVolume<ExperimentalWithCallbackMethod_UpdateVoluemMeta<ExperimentalWithCallbackMethod_GetArrayList<ExperimentalWithCallbackMethod_GetVolumeList<Service > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateArray() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateArray(::grpc::ServerContext* /*context*/, const ::pos_rpc::CreateArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteArray() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_DeleteArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteArray(::grpc::ServerContext* /*context*/, const ::pos_rpc::DeleteArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateVolume() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_CreateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::CreateVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteVolume() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_DeleteVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::DeleteVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MountVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MountVolume() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_MountVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MountVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::MountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnmountVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnmountVolume() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_UnmountVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnmountVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::UnmountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateVoluemMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateVoluemMeta() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_UpdateVoluemMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetArrayList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetArrayList() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetArrayList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArrayList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetArrayListRequest* /*request*/, ::pos_rpc::ArrayListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVolumeList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVolumeList() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetVolumeList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolumeList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateArray() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateArray(::grpc::ServerContext* /*context*/, const ::pos_rpc::CreateArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateArray(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteArray() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_DeleteArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteArray(::grpc::ServerContext* /*context*/, const ::pos_rpc::DeleteArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteArray(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateVolume() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_CreateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::CreateVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteVolume() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_DeleteVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::DeleteVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MountVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MountVolume() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_MountVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MountVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::MountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMountVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnmountVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnmountVolume() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_UnmountVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnmountVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::UnmountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnmountVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateVoluemMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateVoluemMeta() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_UpdateVoluemMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateVoluemMeta(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetArrayList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetArrayList() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetArrayList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArrayList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetArrayListRequest* /*request*/, ::pos_rpc::ArrayListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetArrayList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVolumeList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVolumeList() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_GetVolumeList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolumeList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVolumeList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateArray(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateArray(::grpc::ServerContext* /*context*/, const ::pos_rpc::CreateArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateArray(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteArray() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteArray(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteArray(::grpc::ServerContext* /*context*/, const ::pos_rpc::DeleteArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteArray(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteArray(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::CreateVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::DeleteVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MountVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MountVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MountVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MountVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MountVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::MountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MountVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MountVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnmountVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnmountVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnmountVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnmountVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnmountVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::UnmountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnmountVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnmountVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateVoluemMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateVoluemMeta() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateVoluemMeta(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateVoluemMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateVoluemMeta(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateVoluemMeta(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetArrayList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetArrayList() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetArrayList(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetArrayList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArrayList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetArrayListRequest* /*request*/, ::pos_rpc::ArrayListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetArrayList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetArrayList(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVolumeList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVolumeList() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVolumeList(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVolumeList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolumeList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVolumeList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVolumeList(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateArray() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::CreateArrayRequest, ::pos_rpc::PosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::CreateArrayRequest, ::pos_rpc::PosResponse>* streamer) {
                       return this->StreamedCreateArray(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateArray(::grpc::ServerContext* /*context*/, const ::pos_rpc::CreateArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateArray(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::CreateArrayRequest,::pos_rpc::PosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteArray : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteArray() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::DeleteArrayRequest, ::pos_rpc::PosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::DeleteArrayRequest, ::pos_rpc::PosResponse>* streamer) {
                       return this->StreamedDeleteArray(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteArray() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteArray(::grpc::ServerContext* /*context*/, const ::pos_rpc::DeleteArrayRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteArray(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::DeleteArrayRequest,::pos_rpc::PosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateVolume() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::CreateVolumeRequest, ::pos_rpc::PosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::CreateVolumeRequest, ::pos_rpc::PosResponse>* streamer) {
                       return this->StreamedCreateVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::CreateVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::CreateVolumeRequest,::pos_rpc::PosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteVolume() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::DeleteVolumeRequest, ::pos_rpc::PosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::DeleteVolumeRequest, ::pos_rpc::PosResponse>* streamer) {
                       return this->StreamedDeleteVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::DeleteVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::DeleteVolumeRequest,::pos_rpc::PosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MountVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MountVolume() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::MountVolumeRequest, ::pos_rpc::PosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::MountVolumeRequest, ::pos_rpc::PosResponse>* streamer) {
                       return this->StreamedMountVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MountVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MountVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::MountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMountVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::MountVolumeRequest,::pos_rpc::PosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnmountVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnmountVolume() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::UnmountVolumeRequest, ::pos_rpc::PosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::UnmountVolumeRequest, ::pos_rpc::PosResponse>* streamer) {
                       return this->StreamedUnmountVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnmountVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnmountVolume(::grpc::ServerContext* /*context*/, const ::pos_rpc::UnmountVolumeRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnmountVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::UnmountVolumeRequest,::pos_rpc::PosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateVoluemMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateVoluemMeta() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::UpdateVoluemMetaRequest, ::pos_rpc::PosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::UpdateVoluemMetaRequest, ::pos_rpc::PosResponse>* streamer) {
                       return this->StreamedUpdateVoluemMeta(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateVoluemMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateVoluemMeta(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::UpdateVoluemMetaRequest,::pos_rpc::PosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetArrayList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetArrayList() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::GetArrayListRequest, ::pos_rpc::ArrayListResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::GetArrayListRequest, ::pos_rpc::ArrayListResponse>* streamer) {
                       return this->StreamedGetArrayList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetArrayList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetArrayList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetArrayListRequest* /*request*/, ::pos_rpc::ArrayListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetArrayList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::GetArrayListRequest,::pos_rpc::ArrayListResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVolumeList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVolumeList() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::GetVolumeListRequest, ::pos_rpc::VolumeListResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::GetVolumeListRequest, ::pos_rpc::VolumeListResponse>* streamer) {
                       return this->StreamedGetVolumeList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVolumeList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVolumeList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVolumeList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::GetVolumeListRequest,::pos_rpc::VolumeListResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateArray<WithStreamedUnaryMethod_DeleteArray<WithStreamedUnaryMethod_CreateVolume<WithStreamedUnaryMethod_DeleteVolume<WithStreamedUnaryMethod_MountVolume<WithStreamedUnaryMethod_UnmountVolume<WithStreamedUnaryMethod_UpdateVoluemMeta<WithStreamedUnaryMethod_GetArrayList<WithStreamedUnaryMethod_GetVolumeList<Service > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateArray<WithStreamedUnaryMethod_DeleteArray<WithStreamedUnaryMethod_CreateVolume<WithStreamedUnaryMethod_DeleteVolume<WithStreamedUnaryMethod_MountVolume<WithStreamedUnaryMethod_UnmountVolume<WithStreamedUnaryMethod_UpdateVoluemMeta<WithStreamedUnaryMethod_GetArrayList<WithStreamedUnaryMethod_GetVolumeList<Service > > > > > > > > > StreamedService;
};

// /////////////////////////////////////////////////////////////////////////////////
//
class PosIo final {
 public:
  static constexpr char const* service_full_name() {
    return "pos_rpc.PosIo";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::pos_rpc::ReadBlocksResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksResponse>> AsyncReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksResponse>>(AsyncReadBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksResponse>> PrepareAsyncReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksResponse>>(PrepareAsyncReadBlocksRaw(context, request, cq));
    }
    virtual ::grpc::Status WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::pos_rpc::WriteBlocksResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksResponse>> AsyncWriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksResponse>>(AsyncWriteBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksResponse>> PrepareAsyncWriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksResponse>>(PrepareAsyncWriteBlocksRaw(context, request, cq));
    }
    virtual ::grpc::Status WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::pos_rpc::WriteHostBlocksResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksResponse>> AsyncWriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksResponse>>(AsyncWriteHostBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksResponse>> PrepareAsyncWriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksResponse>>(PrepareAsyncWriteHostBlocksRaw(context, request, cq));
    }
    // rpc ReadBlocksSync(ReadBlocksSyncRequest) returns (ReadBlocksSyncResponse) {} // FakePOS-only sync API
    // rpc WriteBlocksSync(WriteBlocksSyncRequest) returns (WriteBlocksSyncResponse) {} // FakePOS-only sync API
    // rpc WriteHostRequestSync(WriteHostRequestSyncRequest) returns (WriteHostRequestSyncResponse) {} // FakePOS-only sync API
    virtual ::grpc::Status CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::pos_rpc::CompleteHostWriteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::CompleteHostWriteResponse>> AsyncCompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::CompleteHostWriteResponse>>(AsyncCompleteHostWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::CompleteHostWriteResponse>> PrepareAsyncCompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::CompleteHostWriteResponse>>(PrepareAsyncCompleteHostWriteRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // rpc ReadBlocksSync(ReadBlocksSyncRequest) returns (ReadBlocksSyncResponse) {} // FakePOS-only sync API
      // rpc WriteBlocksSync(WriteBlocksSyncRequest) returns (WriteBlocksSyncResponse) {} // FakePOS-only sync API
      // rpc WriteHostRequestSync(WriteHostRequestSyncRequest) returns (WriteHostRequestSyncResponse) {} // FakePOS-only sync API
      virtual void CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksResponse>* AsyncReadBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksResponse>* PrepareAsyncReadBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksResponse>* AsyncWriteBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksResponse>* PrepareAsyncWriteBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksResponse>* AsyncWriteHostBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksResponse>* PrepareAsyncWriteHostBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::CompleteHostWriteResponse>* AsyncCompleteHostWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::CompleteHostWriteResponse>* PrepareAsyncCompleteHostWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::pos_rpc::ReadBlocksResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksResponse>> AsyncReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksResponse>>(AsyncReadBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksResponse>> PrepareAsyncReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksResponse>>(PrepareAsyncReadBlocksRaw(context, request, cq));
    }
    ::grpc::Status WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::pos_rpc::WriteBlocksResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksResponse>> AsyncWriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksResponse>>(AsyncWriteBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksResponse>> PrepareAsyncWriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksResponse>>(PrepareAsyncWriteBlocksRaw(context, request, cq));
    }
    ::grpc::Status WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::pos_rpc::WriteHostBlocksResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksResponse>> AsyncWriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksResponse>>(AsyncWriteHostBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksResponse>> PrepareAsyncWriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksResponse>>(PrepareAsyncWriteHostBlocksRaw(context, request, cq));
    }
    ::grpc::Status CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::pos_rpc::CompleteHostWriteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::CompleteHostWriteResponse>> AsyncCompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::CompleteHostWriteResponse>>(AsyncCompleteHostWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::CompleteHostWriteResponse>> PrepareAsyncCompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::CompleteHostWriteResponse>>(PrepareAsyncCompleteHostWriteRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksResponse>* AsyncReadBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksResponse>* PrepareAsyncReadBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksResponse>* AsyncWriteBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksResponse>* PrepareAsyncWriteBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksResponse>* AsyncWriteHostBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksResponse>* PrepareAsyncWriteHostBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::CompleteHostWriteResponse>* AsyncCompleteHostWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::CompleteHostWriteResponse>* PrepareAsyncCompleteHostWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ReadBlocks_;
    const ::grpc::internal::RpcMethod rpcmethod_WriteBlocks_;
    const ::grpc::internal::RpcMethod rpcmethod_WriteHostBlocks_;
    const ::grpc::internal::RpcMethod rpcmethod_CompleteHostWrite_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ReadBlocks(::grpc::ServerContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response);
    virtual ::grpc::Status WriteBlocks(::grpc::ServerContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response);
    virtual ::grpc::Status WriteHostBlocks(::grpc::ServerContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response);
    // rpc ReadBlocksSync(ReadBlocksSyncRequest) returns (ReadBlocksSyncResponse) {} // FakePOS-only sync API
    // rpc WriteBlocksSync(WriteBlocksSyncRequest) returns (WriteBlocksSyncResponse) {} // FakePOS-only sync API
    // rpc WriteHostRequestSync(WriteHostRequestSyncRequest) returns (WriteHostRequestSyncResponse) {} // FakePOS-only sync API
    virtual ::grpc::Status CompleteHostWrite(::grpc::ServerContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadBlocks() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ReadBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadBlocks(::grpc::ServerContext* context, ::pos_rpc::ReadBlocksRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::ReadBlocksResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WriteBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WriteBlocks() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_WriteBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteBlocks(::grpc::ServerContext* context, ::pos_rpc::WriteBlocksRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::WriteBlocksResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WriteHostBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WriteHostBlocks() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_WriteHostBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteHostBlocks(::grpc::ServerContext* context, ::pos_rpc::WriteHostBlocksRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::WriteHostBlocksResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CompleteHostWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CompleteHostWrite() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_CompleteHostWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteHostWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCompleteHostWrite(::grpc::ServerContext* context, ::pos_rpc::CompleteHostWriteRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::CompleteHostWriteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ReadBlocks<WithAsyncMethod_WriteBlocks<WithAsyncMethod_WriteHostBlocks<WithAsyncMethod_CompleteHostWrite<Service > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReadBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReadBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::ReadBlocksRequest, ::pos_rpc::ReadBlocksResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response) { return this->ReadBlocks(context, request, response); }));}
    void SetMessageAllocatorFor_ReadBlocks(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::ReadBlocksRequest, ::pos_rpc::ReadBlocksResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::ReadBlocksRequest, ::pos_rpc::ReadBlocksResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReadBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WriteBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WriteBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::WriteBlocksRequest, ::pos_rpc::WriteBlocksResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response) { return this->WriteBlocks(context, request, response); }));}
    void SetMessageAllocatorFor_WriteBlocks(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::WriteBlocksRequest, ::pos_rpc::WriteBlocksResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::WriteBlocksRequest, ::pos_rpc::WriteBlocksResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WriteBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WriteHostBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WriteHostBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::WriteHostBlocksRequest, ::pos_rpc::WriteHostBlocksResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response) { return this->WriteHostBlocks(context, request, response); }));}
    void SetMessageAllocatorFor_WriteHostBlocks(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::WriteHostBlocksRequest, ::pos_rpc::WriteHostBlocksResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::WriteHostBlocksRequest, ::pos_rpc::WriteHostBlocksResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WriteHostBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteHostBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteHostBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CompleteHostWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CompleteHostWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::CompleteHostWriteRequest, ::pos_rpc::CompleteHostWriteResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response) { return this->CompleteHostWrite(context, request, response); }));}
    void SetMessageAllocatorFor_CompleteHostWrite(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::CompleteHostWriteRequest, ::pos_rpc::CompleteHostWriteResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::CompleteHostWriteRequest, ::pos_rpc::CompleteHostWriteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CompleteHostWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteHostWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CompleteHostWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CompleteHostWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_ReadBlocks<ExperimentalWithCallbackMethod_WriteBlocks<ExperimentalWithCallbackMethod_WriteHostBlocks<ExperimentalWithCallbackMethod_CompleteHostWrite<Service > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_ReadBlocks<ExperimentalWithCallbackMethod_WriteBlocks<ExperimentalWithCallbackMethod_WriteHostBlocks<ExperimentalWithCallbackMethod_CompleteHostWrite<Service > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ReadBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadBlocks() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ReadBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WriteBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WriteBlocks() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_WriteBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WriteHostBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WriteHostBlocks() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_WriteHostBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CompleteHostWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CompleteHostWrite() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_CompleteHostWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteHostWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadBlocks() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ReadBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadBlocks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WriteBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WriteBlocks() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_WriteBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteBlocks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WriteHostBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WriteHostBlocks() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_WriteHostBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteHostBlocks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CompleteHostWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CompleteHostWrite() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_CompleteHostWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteHostWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCompleteHostWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReadBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReadBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadBlocks(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReadBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WriteBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WriteBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WriteBlocks(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_WriteBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WriteHostBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WriteHostBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WriteHostBlocks(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_WriteHostBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteHostBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteHostBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CompleteHostWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CompleteHostWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CompleteHostWrite(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CompleteHostWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteHostWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CompleteHostWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CompleteHostWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadBlocks() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::ReadBlocksRequest, ::pos_rpc::ReadBlocksResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::ReadBlocksRequest, ::pos_rpc::ReadBlocksResponse>* streamer) {
                       return this->StreamedReadBlocks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadBlocks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::ReadBlocksRequest,::pos_rpc::ReadBlocksResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WriteBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WriteBlocks() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::WriteBlocksRequest, ::pos_rpc::WriteBlocksResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::WriteBlocksRequest, ::pos_rpc::WriteBlocksResponse>* streamer) {
                       return this->StreamedWriteBlocks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WriteBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WriteBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWriteBlocks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::WriteBlocksRequest,::pos_rpc::WriteBlocksResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WriteHostBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WriteHostBlocks() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::WriteHostBlocksRequest, ::pos_rpc::WriteHostBlocksResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::WriteHostBlocksRequest, ::pos_rpc::WriteHostBlocksResponse>* streamer) {
                       return this->StreamedWriteHostBlocks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WriteHostBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WriteHostBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWriteHostBlocks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::WriteHostBlocksRequest,::pos_rpc::WriteHostBlocksResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CompleteHostWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CompleteHostWrite() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::CompleteHostWriteRequest, ::pos_rpc::CompleteHostWriteResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::CompleteHostWriteRequest, ::pos_rpc::CompleteHostWriteResponse>* streamer) {
                       return this->StreamedCompleteHostWrite(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CompleteHostWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CompleteHostWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCompleteHostWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::CompleteHostWriteRequest,::pos_rpc::CompleteHostWriteResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ReadBlocks<WithStreamedUnaryMethod_WriteBlocks<WithStreamedUnaryMethod_WriteHostBlocks<WithStreamedUnaryMethod_CompleteHostWrite<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ReadBlocks<WithStreamedUnaryMethod_WriteBlocks<WithStreamedUnaryMethod_WriteHostBlocks<WithStreamedUnaryMethod_CompleteHostWrite<Service > > > > StreamedService;
};

// /////////////////////////////////////////////////////////////////////////////////
//
class PosControl final {
 public:
  static constexpr char const* service_full_name() {
    return "pos_rpc.PosControl";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::pos_rpc::StartVolumeSyncResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::StartVolumeSyncResponse>> AsyncStartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::StartVolumeSyncResponse>>(AsyncStartVolumeSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::StartVolumeSyncResponse>> PrepareAsyncStartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::StartVolumeSyncResponse>>(PrepareAsyncStartVolumeSyncRaw(context, request, cq));
    }
    virtual ::grpc::Status FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::pos_rpc::FinishVolumeSyncResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::FinishVolumeSyncResponse>> AsyncFinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::FinishVolumeSyncResponse>>(AsyncFinishVolumeSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::FinishVolumeSyncResponse>> PrepareAsyncFinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::FinishVolumeSyncResponse>>(PrepareAsyncFinishVolumeSyncRaw(context, request, cq));
    }
    virtual ::grpc::Status SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::pos_rpc::SuspendWriteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::SuspendWriteResponse>> AsyncSuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::SuspendWriteResponse>>(AsyncSuspendWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::SuspendWriteResponse>> PrepareAsyncSuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::SuspendWriteResponse>>(PrepareAsyncSuspendWriteRaw(context, request, cq));
    }
    virtual ::grpc::Status ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::pos_rpc::ResumeWriteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ResumeWriteResponse>> AsyncResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ResumeWriteResponse>>(AsyncResumeWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ResumeWriteResponse>> PrepareAsyncResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ResumeWriteResponse>>(PrepareAsyncResumeWriteRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::StartVolumeSyncResponse>* AsyncStartVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::StartVolumeSyncResponse>* PrepareAsyncStartVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::FinishVolumeSyncResponse>* AsyncFinishVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::FinishVolumeSyncResponse>* PrepareAsyncFinishVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::SuspendWriteResponse>* AsyncSuspendWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::SuspendWriteResponse>* PrepareAsyncSuspendWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ResumeWriteResponse>* AsyncResumeWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ResumeWriteResponse>* PrepareAsyncResumeWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::pos_rpc::StartVolumeSyncResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::StartVolumeSyncResponse>> AsyncStartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::StartVolumeSyncResponse>>(AsyncStartVolumeSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::StartVolumeSyncResponse>> PrepareAsyncStartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::StartVolumeSyncResponse>>(PrepareAsyncStartVolumeSyncRaw(context, request, cq));
    }
    ::grpc::Status FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::pos_rpc::FinishVolumeSyncResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::FinishVolumeSyncResponse>> AsyncFinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::FinishVolumeSyncResponse>>(AsyncFinishVolumeSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::FinishVolumeSyncResponse>> PrepareAsyncFinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::FinishVolumeSyncResponse>>(PrepareAsyncFinishVolumeSyncRaw(context, request, cq));
    }
    ::grpc::Status SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::pos_rpc::SuspendWriteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::SuspendWriteResponse>> AsyncSuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::SuspendWriteResponse>>(AsyncSuspendWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::SuspendWriteResponse>> PrepareAsyncSuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::SuspendWriteResponse>>(PrepareAsyncSuspendWriteRaw(context, request, cq));
    }
    ::grpc::Status ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::pos_rpc::ResumeWriteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ResumeWriteResponse>> AsyncResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ResumeWriteResponse>>(AsyncResumeWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ResumeWriteResponse>> PrepareAsyncResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ResumeWriteResponse>>(PrepareAsyncResumeWriteRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::StartVolumeSyncResponse>* AsyncStartVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::StartVolumeSyncResponse>* PrepareAsyncStartVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::FinishVolumeSyncResponse>* AsyncFinishVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::FinishVolumeSyncResponse>* PrepareAsyncFinishVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::SuspendWriteResponse>* AsyncSuspendWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::SuspendWriteResponse>* PrepareAsyncSuspendWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ResumeWriteResponse>* AsyncResumeWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ResumeWriteResponse>* PrepareAsyncResumeWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_StartVolumeSync_;
    const ::grpc::internal::RpcMethod rpcmethod_FinishVolumeSync_;
    const ::grpc::internal::RpcMethod rpcmethod_SuspendWrite_;
    const ::grpc::internal::RpcMethod rpcmethod_ResumeWrite_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status StartVolumeSync(::grpc::ServerContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response);
    virtual ::grpc::Status FinishVolumeSync(::grpc::ServerContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response);
    virtual ::grpc::Status SuspendWrite(::grpc::ServerContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response);
    virtual ::grpc::Status ResumeWrite(::grpc::ServerContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_StartVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartVolumeSync() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_StartVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartVolumeSync(::grpc::ServerContext* context, ::pos_rpc::StartVolumeSyncRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::StartVolumeSyncResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FinishVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FinishVolumeSync() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_FinishVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FinishVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFinishVolumeSync(::grpc::ServerContext* context, ::pos_rpc::FinishVolumeSyncRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::FinishVolumeSyncResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SuspendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SuspendWrite() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SuspendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SuspendWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSuspendWrite(::grpc::ServerContext* context, ::pos_rpc::SuspendWriteRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::SuspendWriteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResumeWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResumeWrite() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ResumeWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResumeWrite(::grpc::ServerContext* context, ::pos_rpc::ResumeWriteRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::ResumeWriteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_StartVolumeSync<WithAsyncMethod_FinishVolumeSync<WithAsyncMethod_SuspendWrite<WithAsyncMethod_ResumeWrite<Service > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StartVolumeSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::StartVolumeSyncRequest, ::pos_rpc::StartVolumeSyncResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response) { return this->StartVolumeSync(context, request, response); }));}
    void SetMessageAllocatorFor_StartVolumeSync(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::StartVolumeSyncRequest, ::pos_rpc::StartVolumeSyncResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::StartVolumeSyncRequest, ::pos_rpc::StartVolumeSyncResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StartVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StartVolumeSync(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StartVolumeSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FinishVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FinishVolumeSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::FinishVolumeSyncRequest, ::pos_rpc::FinishVolumeSyncResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response) { return this->FinishVolumeSync(context, request, response); }));}
    void SetMessageAllocatorFor_FinishVolumeSync(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::FinishVolumeSyncRequest, ::pos_rpc::FinishVolumeSyncResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::FinishVolumeSyncRequest, ::pos_rpc::FinishVolumeSyncResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FinishVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FinishVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FinishVolumeSync(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FinishVolumeSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SuspendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SuspendWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::SuspendWriteRequest, ::pos_rpc::SuspendWriteResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response) { return this->SuspendWrite(context, request, response); }));}
    void SetMessageAllocatorFor_SuspendWrite(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::SuspendWriteRequest, ::pos_rpc::SuspendWriteResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::SuspendWriteRequest, ::pos_rpc::SuspendWriteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SuspendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SuspendWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SuspendWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SuspendWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ResumeWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ResumeWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::ResumeWriteRequest, ::pos_rpc::ResumeWriteResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response) { return this->ResumeWrite(context, request, response); }));}
    void SetMessageAllocatorFor_ResumeWrite(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::ResumeWriteRequest, ::pos_rpc::ResumeWriteResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::ResumeWriteRequest, ::pos_rpc::ResumeWriteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ResumeWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ResumeWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ResumeWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_StartVolumeSync<ExperimentalWithCallbackMethod_FinishVolumeSync<ExperimentalWithCallbackMethod_SuspendWrite<ExperimentalWithCallbackMethod_ResumeWrite<Service > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_StartVolumeSync<ExperimentalWithCallbackMethod_FinishVolumeSync<ExperimentalWithCallbackMethod_SuspendWrite<ExperimentalWithCallbackMethod_ResumeWrite<Service > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_StartVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartVolumeSync() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_StartVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FinishVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FinishVolumeSync() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_FinishVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FinishVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SuspendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SuspendWrite() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SuspendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SuspendWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResumeWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResumeWrite() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ResumeWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartVolumeSync() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_StartVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartVolumeSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FinishVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FinishVolumeSync() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_FinishVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FinishVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFinishVolumeSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SuspendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SuspendWrite() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SuspendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SuspendWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSuspendWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResumeWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResumeWrite() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ResumeWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResumeWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StartVolumeSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartVolumeSync(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_StartVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StartVolumeSync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StartVolumeSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FinishVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FinishVolumeSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FinishVolumeSync(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FinishVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FinishVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FinishVolumeSync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FinishVolumeSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SuspendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SuspendWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SuspendWrite(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SuspendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SuspendWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SuspendWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SuspendWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ResumeWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ResumeWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResumeWrite(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ResumeWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ResumeWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ResumeWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartVolumeSync() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::StartVolumeSyncRequest, ::pos_rpc::StartVolumeSyncResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::StartVolumeSyncRequest, ::pos_rpc::StartVolumeSyncResponse>* streamer) {
                       return this->StreamedStartVolumeSync(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartVolumeSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::StartVolumeSyncRequest,::pos_rpc::StartVolumeSyncResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FinishVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FinishVolumeSync() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::FinishVolumeSyncRequest, ::pos_rpc::FinishVolumeSyncResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::FinishVolumeSyncRequest, ::pos_rpc::FinishVolumeSyncResponse>* streamer) {
                       return this->StreamedFinishVolumeSync(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FinishVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FinishVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFinishVolumeSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::FinishVolumeSyncRequest,::pos_rpc::FinishVolumeSyncResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SuspendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SuspendWrite() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::SuspendWriteRequest, ::pos_rpc::SuspendWriteResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::SuspendWriteRequest, ::pos_rpc::SuspendWriteResponse>* streamer) {
                       return this->StreamedSuspendWrite(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SuspendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SuspendWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSuspendWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::SuspendWriteRequest,::pos_rpc::SuspendWriteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResumeWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResumeWrite() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::ResumeWriteRequest, ::pos_rpc::ResumeWriteResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::ResumeWriteRequest, ::pos_rpc::ResumeWriteResponse>* streamer) {
                       return this->StreamedResumeWrite(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResumeWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResumeWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResumeWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::ResumeWriteRequest,::pos_rpc::ResumeWriteResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_StartVolumeSync<WithStreamedUnaryMethod_FinishVolumeSync<WithStreamedUnaryMethod_SuspendWrite<WithStreamedUnaryMethod_ResumeWrite<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_StartVolumeSync<WithStreamedUnaryMethod_FinishVolumeSync<WithStreamedUnaryMethod_SuspendWrite<WithStreamedUnaryMethod_ResumeWrite<Service > > > > StreamedService;
};

}  // namespace pos_rpc


#endif  // GRPC_pos_5frpc_2eproto__INCLUDED
