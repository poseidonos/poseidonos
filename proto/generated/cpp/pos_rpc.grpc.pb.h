// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: pos_rpc.proto
#ifndef GRPC_pos_5frpc_2eproto__INCLUDED
#define GRPC_pos_5frpc_2eproto__INCLUDED

#include "pos_rpc.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace pos_rpc {

class Health final {
 public:
  static constexpr char const* service_full_name() {
    return "pos_rpc.Health";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::pos_rpc::HealthCheckResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::HealthCheckResponse>> AsyncCheck(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::HealthCheckResponse>>(AsyncCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::HealthCheckResponse>> PrepareAsyncCheck(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::HealthCheckResponse>>(PrepareAsyncCheckRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::HealthCheckResponse>* AsyncCheckRaw(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::HealthCheckResponse>* PrepareAsyncCheckRaw(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::pos_rpc::HealthCheckResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::HealthCheckResponse>> AsyncCheck(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::HealthCheckResponse>>(AsyncCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::HealthCheckResponse>> PrepareAsyncCheck(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::HealthCheckResponse>>(PrepareAsyncCheckRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Check(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::HealthCheckResponse>* AsyncCheckRaw(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::HealthCheckResponse>* PrepareAsyncCheckRaw(::grpc::ClientContext* context, const ::pos_rpc::HealthCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Check_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Check(::grpc::ServerContext* context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Check() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheck(::grpc::ServerContext* context, ::pos_rpc::HealthCheckRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::HealthCheckResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Check<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Check() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::HealthCheckRequest, ::pos_rpc::HealthCheckResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::HealthCheckRequest* request, ::pos_rpc::HealthCheckResponse* response) { return this->Check(context, request, response); }));}
    void SetMessageAllocatorFor_Check(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::HealthCheckRequest, ::pos_rpc::HealthCheckResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::HealthCheckRequest, ::pos_rpc::HealthCheckResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Check(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Check(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Check<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Check<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Check() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Check() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheck(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Check() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Check(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Check(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Check(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Check() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::HealthCheckRequest, ::pos_rpc::HealthCheckResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::HealthCheckRequest, ::pos_rpc::HealthCheckResponse>* streamer) {
                       return this->StreamedCheck(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::pos_rpc::HealthCheckRequest* /*request*/, ::pos_rpc::HealthCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheck(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::HealthCheckRequest,::pos_rpc::HealthCheckResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Check<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Check<Service > StreamedService;
};

// /////////////////////////////////////////////////////////////////////////////////
//
class PosManagement final {
 public:
  static constexpr char const* service_full_name() {
    return "pos_rpc.PosManagement";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::pos_rpc::PosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> AsyncUpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(AsyncUpdateVoluemMetaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>> PrepareAsyncUpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>>(PrepareAsyncUpdateVoluemMetaRaw(context, request, cq));
    }
    virtual ::grpc::Status GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::pos_rpc::VolumeListResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::VolumeListResponse>> AsyncGetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::VolumeListResponse>>(AsyncGetVolumeListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::VolumeListResponse>> PrepareAsyncGetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::VolumeListResponse>>(PrepareAsyncGetVolumeListRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* AsyncUpdateVoluemMetaRaw(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::PosResponse>* PrepareAsyncUpdateVoluemMetaRaw(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::VolumeListResponse>* AsyncGetVolumeListRaw(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::VolumeListResponse>* PrepareAsyncGetVolumeListRaw(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::pos_rpc::PosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> AsyncUpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(AsyncUpdateVoluemMetaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>> PrepareAsyncUpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>>(PrepareAsyncUpdateVoluemMetaRaw(context, request, cq));
    }
    ::grpc::Status GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::pos_rpc::VolumeListResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::VolumeListResponse>> AsyncGetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::VolumeListResponse>>(AsyncGetVolumeListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::VolumeListResponse>> PrepareAsyncGetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::VolumeListResponse>>(PrepareAsyncGetVolumeListRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateVoluemMeta(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetVolumeList(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* AsyncUpdateVoluemMetaRaw(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::PosResponse>* PrepareAsyncUpdateVoluemMetaRaw(::grpc::ClientContext* context, const ::pos_rpc::UpdateVoluemMetaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::VolumeListResponse>* AsyncGetVolumeListRaw(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::VolumeListResponse>* PrepareAsyncGetVolumeListRaw(::grpc::ClientContext* context, const ::pos_rpc::GetVolumeListRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateVoluemMeta_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVolumeList_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response);
    virtual ::grpc::Status GetVolumeList(::grpc::ServerContext* context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateVoluemMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateVoluemMeta() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_UpdateVoluemMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateVoluemMeta(::grpc::ServerContext* context, ::pos_rpc::UpdateVoluemMetaRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::PosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVolumeList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVolumeList() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetVolumeList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolumeList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVolumeList(::grpc::ServerContext* context, ::pos_rpc::GetVolumeListRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::VolumeListResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_UpdateVoluemMeta<WithAsyncMethod_GetVolumeList<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateVoluemMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateVoluemMeta() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::UpdateVoluemMetaRequest, ::pos_rpc::PosResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::UpdateVoluemMetaRequest* request, ::pos_rpc::PosResponse* response) { return this->UpdateVoluemMeta(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateVoluemMeta(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::UpdateVoluemMetaRequest, ::pos_rpc::PosResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::UpdateVoluemMetaRequest, ::pos_rpc::PosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateVoluemMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateVoluemMeta(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateVoluemMeta(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVolumeList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetVolumeList() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::GetVolumeListRequest, ::pos_rpc::VolumeListResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::GetVolumeListRequest* request, ::pos_rpc::VolumeListResponse* response) { return this->GetVolumeList(context, request, response); }));}
    void SetMessageAllocatorFor_GetVolumeList(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::GetVolumeListRequest, ::pos_rpc::VolumeListResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::GetVolumeListRequest, ::pos_rpc::VolumeListResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetVolumeList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolumeList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVolumeList(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVolumeList(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_UpdateVoluemMeta<ExperimentalWithCallbackMethod_GetVolumeList<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_UpdateVoluemMeta<ExperimentalWithCallbackMethod_GetVolumeList<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_UpdateVoluemMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateVoluemMeta() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_UpdateVoluemMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVolumeList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVolumeList() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetVolumeList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolumeList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateVoluemMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateVoluemMeta() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_UpdateVoluemMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateVoluemMeta(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVolumeList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVolumeList() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetVolumeList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolumeList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVolumeList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateVoluemMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateVoluemMeta() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateVoluemMeta(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateVoluemMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateVoluemMeta(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateVoluemMeta(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVolumeList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVolumeList() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVolumeList(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVolumeList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolumeList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVolumeList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVolumeList(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateVoluemMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateVoluemMeta() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::UpdateVoluemMetaRequest, ::pos_rpc::PosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::UpdateVoluemMetaRequest, ::pos_rpc::PosResponse>* streamer) {
                       return this->StreamedUpdateVoluemMeta(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateVoluemMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateVoluemMeta(::grpc::ServerContext* /*context*/, const ::pos_rpc::UpdateVoluemMetaRequest* /*request*/, ::pos_rpc::PosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateVoluemMeta(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::UpdateVoluemMetaRequest,::pos_rpc::PosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVolumeList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVolumeList() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::GetVolumeListRequest, ::pos_rpc::VolumeListResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::GetVolumeListRequest, ::pos_rpc::VolumeListResponse>* streamer) {
                       return this->StreamedGetVolumeList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVolumeList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVolumeList(::grpc::ServerContext* /*context*/, const ::pos_rpc::GetVolumeListRequest* /*request*/, ::pos_rpc::VolumeListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVolumeList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::GetVolumeListRequest,::pos_rpc::VolumeListResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_UpdateVoluemMeta<WithStreamedUnaryMethod_GetVolumeList<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_UpdateVoluemMeta<WithStreamedUnaryMethod_GetVolumeList<Service > > StreamedService;
};

// /////////////////////////////////////////////////////////////////////////////////
//
class PosIo final {
 public:
  static constexpr char const* service_full_name() {
    return "pos_rpc.PosIo";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::pos_rpc::ReadBlocksResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksResponse>> AsyncReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksResponse>>(AsyncReadBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksResponse>> PrepareAsyncReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksResponse>>(PrepareAsyncReadBlocksRaw(context, request, cq));
    }
    virtual ::grpc::Status WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::pos_rpc::WriteBlocksResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksResponse>> AsyncWriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksResponse>>(AsyncWriteBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksResponse>> PrepareAsyncWriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksResponse>>(PrepareAsyncWriteBlocksRaw(context, request, cq));
    }
    virtual ::grpc::Status WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::pos_rpc::WriteHostBlocksResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksResponse>> AsyncWriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksResponse>>(AsyncWriteHostBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksResponse>> PrepareAsyncWriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksResponse>>(PrepareAsyncWriteHostBlocksRaw(context, request, cq));
    }
    virtual ::grpc::Status ReadBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest& request, ::pos_rpc::ReadBlocksSyncResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksSyncResponse>> AsyncReadBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksSyncResponse>>(AsyncReadBlocksSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksSyncResponse>> PrepareAsyncReadBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksSyncResponse>>(PrepareAsyncReadBlocksSyncRaw(context, request, cq));
    }
    virtual ::grpc::Status WriteBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest& request, ::pos_rpc::WriteBlocksSyncResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksSyncResponse>> AsyncWriteBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksSyncResponse>>(AsyncWriteBlocksSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksSyncResponse>> PrepareAsyncWriteBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksSyncResponse>>(PrepareAsyncWriteBlocksSyncRaw(context, request, cq));
    }
    virtual ::grpc::Status WriteHostBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest& request, ::pos_rpc::WriteHostBlocksSyncResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksSyncResponse>> AsyncWriteHostBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksSyncResponse>>(AsyncWriteHostBlocksSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksSyncResponse>> PrepareAsyncWriteHostBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksSyncResponse>>(PrepareAsyncWriteHostBlocksSyncRaw(context, request, cq));
    }
    virtual ::grpc::Status CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::pos_rpc::CompleteHostWriteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::CompleteHostWriteResponse>> AsyncCompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::CompleteHostWriteResponse>>(AsyncCompleteHostWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::CompleteHostWriteResponse>> PrepareAsyncCompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::CompleteHostWriteResponse>>(PrepareAsyncCompleteHostWriteRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ReadBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest* request, ::pos_rpc::ReadBlocksSyncResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReadBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest* request, ::pos_rpc::ReadBlocksSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReadBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest* request, ::pos_rpc::ReadBlocksSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void WriteBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest* request, ::pos_rpc::WriteBlocksSyncResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WriteBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest* request, ::pos_rpc::WriteBlocksSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WriteBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest* request, ::pos_rpc::WriteBlocksSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void WriteHostBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest* request, ::pos_rpc::WriteHostBlocksSyncResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WriteHostBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest* request, ::pos_rpc::WriteHostBlocksSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WriteHostBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest* request, ::pos_rpc::WriteHostBlocksSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksResponse>* AsyncReadBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksResponse>* PrepareAsyncReadBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksResponse>* AsyncWriteBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksResponse>* PrepareAsyncWriteBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksResponse>* AsyncWriteHostBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksResponse>* PrepareAsyncWriteHostBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksSyncResponse>* AsyncReadBlocksSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ReadBlocksSyncResponse>* PrepareAsyncReadBlocksSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksSyncResponse>* AsyncWriteBlocksSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteBlocksSyncResponse>* PrepareAsyncWriteBlocksSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksSyncResponse>* AsyncWriteHostBlocksSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::WriteHostBlocksSyncResponse>* PrepareAsyncWriteHostBlocksSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::CompleteHostWriteResponse>* AsyncCompleteHostWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::CompleteHostWriteResponse>* PrepareAsyncCompleteHostWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::pos_rpc::ReadBlocksResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksResponse>> AsyncReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksResponse>>(AsyncReadBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksResponse>> PrepareAsyncReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksResponse>>(PrepareAsyncReadBlocksRaw(context, request, cq));
    }
    ::grpc::Status WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::pos_rpc::WriteBlocksResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksResponse>> AsyncWriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksResponse>>(AsyncWriteBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksResponse>> PrepareAsyncWriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksResponse>>(PrepareAsyncWriteBlocksRaw(context, request, cq));
    }
    ::grpc::Status WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::pos_rpc::WriteHostBlocksResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksResponse>> AsyncWriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksResponse>>(AsyncWriteHostBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksResponse>> PrepareAsyncWriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksResponse>>(PrepareAsyncWriteHostBlocksRaw(context, request, cq));
    }
    ::grpc::Status ReadBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest& request, ::pos_rpc::ReadBlocksSyncResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksSyncResponse>> AsyncReadBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksSyncResponse>>(AsyncReadBlocksSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksSyncResponse>> PrepareAsyncReadBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksSyncResponse>>(PrepareAsyncReadBlocksSyncRaw(context, request, cq));
    }
    ::grpc::Status WriteBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest& request, ::pos_rpc::WriteBlocksSyncResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksSyncResponse>> AsyncWriteBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksSyncResponse>>(AsyncWriteBlocksSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksSyncResponse>> PrepareAsyncWriteBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksSyncResponse>>(PrepareAsyncWriteBlocksSyncRaw(context, request, cq));
    }
    ::grpc::Status WriteHostBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest& request, ::pos_rpc::WriteHostBlocksSyncResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksSyncResponse>> AsyncWriteHostBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksSyncResponse>>(AsyncWriteHostBlocksSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksSyncResponse>> PrepareAsyncWriteHostBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksSyncResponse>>(PrepareAsyncWriteHostBlocksSyncRaw(context, request, cq));
    }
    ::grpc::Status CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::pos_rpc::CompleteHostWriteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::CompleteHostWriteResponse>> AsyncCompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::CompleteHostWriteResponse>>(AsyncCompleteHostWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::CompleteHostWriteResponse>> PrepareAsyncCompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::CompleteHostWriteResponse>>(PrepareAsyncCompleteHostWriteRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReadBlocks(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WriteBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WriteHostBlocks(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ReadBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest* request, ::pos_rpc::ReadBlocksSyncResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReadBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest* request, ::pos_rpc::ReadBlocksSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReadBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest* request, ::pos_rpc::ReadBlocksSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void WriteBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest* request, ::pos_rpc::WriteBlocksSyncResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WriteBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest* request, ::pos_rpc::WriteBlocksSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WriteBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest* request, ::pos_rpc::WriteBlocksSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void WriteHostBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest* request, ::pos_rpc::WriteHostBlocksSyncResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WriteHostBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest* request, ::pos_rpc::WriteHostBlocksSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WriteHostBlocksSync(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest* request, ::pos_rpc::WriteHostBlocksSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CompleteHostWrite(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksResponse>* AsyncReadBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksResponse>* PrepareAsyncReadBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksResponse>* AsyncWriteBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksResponse>* PrepareAsyncWriteBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksResponse>* AsyncWriteHostBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksResponse>* PrepareAsyncWriteHostBlocksRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksSyncResponse>* AsyncReadBlocksSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ReadBlocksSyncResponse>* PrepareAsyncReadBlocksSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::ReadBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksSyncResponse>* AsyncWriteBlocksSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteBlocksSyncResponse>* PrepareAsyncWriteBlocksSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksSyncResponse>* AsyncWriteHostBlocksSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::WriteHostBlocksSyncResponse>* PrepareAsyncWriteHostBlocksSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::CompleteHostWriteResponse>* AsyncCompleteHostWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::CompleteHostWriteResponse>* PrepareAsyncCompleteHostWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::CompleteHostWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ReadBlocks_;
    const ::grpc::internal::RpcMethod rpcmethod_WriteBlocks_;
    const ::grpc::internal::RpcMethod rpcmethod_WriteHostBlocks_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadBlocksSync_;
    const ::grpc::internal::RpcMethod rpcmethod_WriteBlocksSync_;
    const ::grpc::internal::RpcMethod rpcmethod_WriteHostBlocksSync_;
    const ::grpc::internal::RpcMethod rpcmethod_CompleteHostWrite_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ReadBlocks(::grpc::ServerContext* context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response);
    virtual ::grpc::Status WriteBlocks(::grpc::ServerContext* context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response);
    virtual ::grpc::Status WriteHostBlocks(::grpc::ServerContext* context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response);
    virtual ::grpc::Status ReadBlocksSync(::grpc::ServerContext* context, const ::pos_rpc::ReadBlocksSyncRequest* request, ::pos_rpc::ReadBlocksSyncResponse* response);
    virtual ::grpc::Status WriteBlocksSync(::grpc::ServerContext* context, const ::pos_rpc::WriteBlocksSyncRequest* request, ::pos_rpc::WriteBlocksSyncResponse* response);
    virtual ::grpc::Status WriteHostBlocksSync(::grpc::ServerContext* context, const ::pos_rpc::WriteHostBlocksSyncRequest* request, ::pos_rpc::WriteHostBlocksSyncResponse* response);
    virtual ::grpc::Status CompleteHostWrite(::grpc::ServerContext* context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadBlocks() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ReadBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadBlocks(::grpc::ServerContext* context, ::pos_rpc::ReadBlocksRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::ReadBlocksResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WriteBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WriteBlocks() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_WriteBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteBlocks(::grpc::ServerContext* context, ::pos_rpc::WriteBlocksRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::WriteBlocksResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WriteHostBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WriteHostBlocks() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_WriteHostBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteHostBlocks(::grpc::ServerContext* context, ::pos_rpc::WriteHostBlocksRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::WriteHostBlocksResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadBlocksSync() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ReadBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksSyncRequest* /*request*/, ::pos_rpc::ReadBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadBlocksSync(::grpc::ServerContext* context, ::pos_rpc::ReadBlocksSyncRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::ReadBlocksSyncResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WriteBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WriteBlocksSync() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_WriteBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksSyncRequest* /*request*/, ::pos_rpc::WriteBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteBlocksSync(::grpc::ServerContext* context, ::pos_rpc::WriteBlocksSyncRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::WriteBlocksSyncResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WriteHostBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WriteHostBlocksSync() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_WriteHostBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksSyncRequest* /*request*/, ::pos_rpc::WriteHostBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteHostBlocksSync(::grpc::ServerContext* context, ::pos_rpc::WriteHostBlocksSyncRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::WriteHostBlocksSyncResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CompleteHostWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CompleteHostWrite() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_CompleteHostWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteHostWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCompleteHostWrite(::grpc::ServerContext* context, ::pos_rpc::CompleteHostWriteRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::CompleteHostWriteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ReadBlocks<WithAsyncMethod_WriteBlocks<WithAsyncMethod_WriteHostBlocks<WithAsyncMethod_ReadBlocksSync<WithAsyncMethod_WriteBlocksSync<WithAsyncMethod_WriteHostBlocksSync<WithAsyncMethod_CompleteHostWrite<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReadBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReadBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::ReadBlocksRequest, ::pos_rpc::ReadBlocksResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::ReadBlocksRequest* request, ::pos_rpc::ReadBlocksResponse* response) { return this->ReadBlocks(context, request, response); }));}
    void SetMessageAllocatorFor_ReadBlocks(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::ReadBlocksRequest, ::pos_rpc::ReadBlocksResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::ReadBlocksRequest, ::pos_rpc::ReadBlocksResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReadBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WriteBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WriteBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::WriteBlocksRequest, ::pos_rpc::WriteBlocksResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::WriteBlocksRequest* request, ::pos_rpc::WriteBlocksResponse* response) { return this->WriteBlocks(context, request, response); }));}
    void SetMessageAllocatorFor_WriteBlocks(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::WriteBlocksRequest, ::pos_rpc::WriteBlocksResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::WriteBlocksRequest, ::pos_rpc::WriteBlocksResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WriteBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WriteHostBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WriteHostBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::WriteHostBlocksRequest, ::pos_rpc::WriteHostBlocksResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::WriteHostBlocksRequest* request, ::pos_rpc::WriteHostBlocksResponse* response) { return this->WriteHostBlocks(context, request, response); }));}
    void SetMessageAllocatorFor_WriteHostBlocks(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::WriteHostBlocksRequest, ::pos_rpc::WriteHostBlocksResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::WriteHostBlocksRequest, ::pos_rpc::WriteHostBlocksResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WriteHostBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteHostBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteHostBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReadBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReadBlocksSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::ReadBlocksSyncRequest, ::pos_rpc::ReadBlocksSyncResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::ReadBlocksSyncRequest* request, ::pos_rpc::ReadBlocksSyncResponse* response) { return this->ReadBlocksSync(context, request, response); }));}
    void SetMessageAllocatorFor_ReadBlocksSync(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::ReadBlocksSyncRequest, ::pos_rpc::ReadBlocksSyncResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::ReadBlocksSyncRequest, ::pos_rpc::ReadBlocksSyncResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReadBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksSyncRequest* /*request*/, ::pos_rpc::ReadBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadBlocksSync(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::ReadBlocksSyncRequest* /*request*/, ::pos_rpc::ReadBlocksSyncResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadBlocksSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::ReadBlocksSyncRequest* /*request*/, ::pos_rpc::ReadBlocksSyncResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WriteBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WriteBlocksSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::WriteBlocksSyncRequest, ::pos_rpc::WriteBlocksSyncResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::WriteBlocksSyncRequest* request, ::pos_rpc::WriteBlocksSyncResponse* response) { return this->WriteBlocksSync(context, request, response); }));}
    void SetMessageAllocatorFor_WriteBlocksSync(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::WriteBlocksSyncRequest, ::pos_rpc::WriteBlocksSyncResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::WriteBlocksSyncRequest, ::pos_rpc::WriteBlocksSyncResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WriteBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksSyncRequest* /*request*/, ::pos_rpc::WriteBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteBlocksSync(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::WriteBlocksSyncRequest* /*request*/, ::pos_rpc::WriteBlocksSyncResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteBlocksSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::WriteBlocksSyncRequest* /*request*/, ::pos_rpc::WriteBlocksSyncResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WriteHostBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WriteHostBlocksSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::WriteHostBlocksSyncRequest, ::pos_rpc::WriteHostBlocksSyncResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::WriteHostBlocksSyncRequest* request, ::pos_rpc::WriteHostBlocksSyncResponse* response) { return this->WriteHostBlocksSync(context, request, response); }));}
    void SetMessageAllocatorFor_WriteHostBlocksSync(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::WriteHostBlocksSyncRequest, ::pos_rpc::WriteHostBlocksSyncResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::WriteHostBlocksSyncRequest, ::pos_rpc::WriteHostBlocksSyncResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WriteHostBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksSyncRequest* /*request*/, ::pos_rpc::WriteHostBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteHostBlocksSync(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksSyncRequest* /*request*/, ::pos_rpc::WriteHostBlocksSyncResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteHostBlocksSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksSyncRequest* /*request*/, ::pos_rpc::WriteHostBlocksSyncResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CompleteHostWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CompleteHostWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::CompleteHostWriteRequest, ::pos_rpc::CompleteHostWriteResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::CompleteHostWriteRequest* request, ::pos_rpc::CompleteHostWriteResponse* response) { return this->CompleteHostWrite(context, request, response); }));}
    void SetMessageAllocatorFor_CompleteHostWrite(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::CompleteHostWriteRequest, ::pos_rpc::CompleteHostWriteResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::CompleteHostWriteRequest, ::pos_rpc::CompleteHostWriteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CompleteHostWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteHostWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CompleteHostWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CompleteHostWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_ReadBlocks<ExperimentalWithCallbackMethod_WriteBlocks<ExperimentalWithCallbackMethod_WriteHostBlocks<ExperimentalWithCallbackMethod_ReadBlocksSync<ExperimentalWithCallbackMethod_WriteBlocksSync<ExperimentalWithCallbackMethod_WriteHostBlocksSync<ExperimentalWithCallbackMethod_CompleteHostWrite<Service > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_ReadBlocks<ExperimentalWithCallbackMethod_WriteBlocks<ExperimentalWithCallbackMethod_WriteHostBlocks<ExperimentalWithCallbackMethod_ReadBlocksSync<ExperimentalWithCallbackMethod_WriteBlocksSync<ExperimentalWithCallbackMethod_WriteHostBlocksSync<ExperimentalWithCallbackMethod_CompleteHostWrite<Service > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ReadBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadBlocks() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ReadBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WriteBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WriteBlocks() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_WriteBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WriteHostBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WriteHostBlocks() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_WriteHostBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadBlocksSync() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ReadBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksSyncRequest* /*request*/, ::pos_rpc::ReadBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WriteBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WriteBlocksSync() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_WriteBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksSyncRequest* /*request*/, ::pos_rpc::WriteBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WriteHostBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WriteHostBlocksSync() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_WriteHostBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksSyncRequest* /*request*/, ::pos_rpc::WriteHostBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CompleteHostWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CompleteHostWrite() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_CompleteHostWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteHostWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadBlocks() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ReadBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadBlocks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WriteBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WriteBlocks() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_WriteBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteBlocks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WriteHostBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WriteHostBlocks() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_WriteHostBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteHostBlocks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadBlocksSync() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ReadBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksSyncRequest* /*request*/, ::pos_rpc::ReadBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadBlocksSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WriteBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WriteBlocksSync() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_WriteBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksSyncRequest* /*request*/, ::pos_rpc::WriteBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteBlocksSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WriteHostBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WriteHostBlocksSync() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_WriteHostBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksSyncRequest* /*request*/, ::pos_rpc::WriteHostBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteHostBlocksSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CompleteHostWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CompleteHostWrite() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_CompleteHostWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteHostWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCompleteHostWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReadBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReadBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadBlocks(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReadBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WriteBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WriteBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WriteBlocks(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_WriteBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WriteHostBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WriteHostBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WriteHostBlocks(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_WriteHostBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteHostBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteHostBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReadBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReadBlocksSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadBlocksSync(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReadBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksSyncRequest* /*request*/, ::pos_rpc::ReadBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadBlocksSync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadBlocksSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WriteBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WriteBlocksSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WriteBlocksSync(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_WriteBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksSyncRequest* /*request*/, ::pos_rpc::WriteBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteBlocksSync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteBlocksSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WriteHostBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WriteHostBlocksSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WriteHostBlocksSync(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_WriteHostBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteHostBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksSyncRequest* /*request*/, ::pos_rpc::WriteHostBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteHostBlocksSync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteHostBlocksSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CompleteHostWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CompleteHostWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CompleteHostWrite(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CompleteHostWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CompleteHostWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CompleteHostWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CompleteHostWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadBlocks() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::ReadBlocksRequest, ::pos_rpc::ReadBlocksResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::ReadBlocksRequest, ::pos_rpc::ReadBlocksResponse>* streamer) {
                       return this->StreamedReadBlocks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksRequest* /*request*/, ::pos_rpc::ReadBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadBlocks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::ReadBlocksRequest,::pos_rpc::ReadBlocksResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WriteBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WriteBlocks() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::WriteBlocksRequest, ::pos_rpc::WriteBlocksResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::WriteBlocksRequest, ::pos_rpc::WriteBlocksResponse>* streamer) {
                       return this->StreamedWriteBlocks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WriteBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WriteBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksRequest* /*request*/, ::pos_rpc::WriteBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWriteBlocks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::WriteBlocksRequest,::pos_rpc::WriteBlocksResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WriteHostBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WriteHostBlocks() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::WriteHostBlocksRequest, ::pos_rpc::WriteHostBlocksResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::WriteHostBlocksRequest, ::pos_rpc::WriteHostBlocksResponse>* streamer) {
                       return this->StreamedWriteHostBlocks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WriteHostBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WriteHostBlocks(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksRequest* /*request*/, ::pos_rpc::WriteHostBlocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWriteHostBlocks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::WriteHostBlocksRequest,::pos_rpc::WriteHostBlocksResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadBlocksSync() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::ReadBlocksSyncRequest, ::pos_rpc::ReadBlocksSyncResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::ReadBlocksSyncRequest, ::pos_rpc::ReadBlocksSyncResponse>* streamer) {
                       return this->StreamedReadBlocksSync(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::ReadBlocksSyncRequest* /*request*/, ::pos_rpc::ReadBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadBlocksSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::ReadBlocksSyncRequest,::pos_rpc::ReadBlocksSyncResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WriteBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WriteBlocksSync() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::WriteBlocksSyncRequest, ::pos_rpc::WriteBlocksSyncResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::WriteBlocksSyncRequest, ::pos_rpc::WriteBlocksSyncResponse>* streamer) {
                       return this->StreamedWriteBlocksSync(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WriteBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WriteBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteBlocksSyncRequest* /*request*/, ::pos_rpc::WriteBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWriteBlocksSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::WriteBlocksSyncRequest,::pos_rpc::WriteBlocksSyncResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WriteHostBlocksSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WriteHostBlocksSync() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::WriteHostBlocksSyncRequest, ::pos_rpc::WriteHostBlocksSyncResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::WriteHostBlocksSyncRequest, ::pos_rpc::WriteHostBlocksSyncResponse>* streamer) {
                       return this->StreamedWriteHostBlocksSync(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WriteHostBlocksSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WriteHostBlocksSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::WriteHostBlocksSyncRequest* /*request*/, ::pos_rpc::WriteHostBlocksSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWriteHostBlocksSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::WriteHostBlocksSyncRequest,::pos_rpc::WriteHostBlocksSyncResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CompleteHostWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CompleteHostWrite() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::CompleteHostWriteRequest, ::pos_rpc::CompleteHostWriteResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::CompleteHostWriteRequest, ::pos_rpc::CompleteHostWriteResponse>* streamer) {
                       return this->StreamedCompleteHostWrite(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CompleteHostWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CompleteHostWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::CompleteHostWriteRequest* /*request*/, ::pos_rpc::CompleteHostWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCompleteHostWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::CompleteHostWriteRequest,::pos_rpc::CompleteHostWriteResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ReadBlocks<WithStreamedUnaryMethod_WriteBlocks<WithStreamedUnaryMethod_WriteHostBlocks<WithStreamedUnaryMethod_ReadBlocksSync<WithStreamedUnaryMethod_WriteBlocksSync<WithStreamedUnaryMethod_WriteHostBlocksSync<WithStreamedUnaryMethod_CompleteHostWrite<Service > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ReadBlocks<WithStreamedUnaryMethod_WriteBlocks<WithStreamedUnaryMethod_WriteHostBlocks<WithStreamedUnaryMethod_ReadBlocksSync<WithStreamedUnaryMethod_WriteBlocksSync<WithStreamedUnaryMethod_WriteHostBlocksSync<WithStreamedUnaryMethod_CompleteHostWrite<Service > > > > > > > StreamedService;
};

// /////////////////////////////////////////////////////////////////////////////////
//
class ReplicationControl final {
 public:
  static constexpr char const* service_full_name() {
    return "pos_rpc.ReplicationControl";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::pos_rpc::StartVolumeSyncResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::StartVolumeSyncResponse>> AsyncStartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::StartVolumeSyncResponse>>(AsyncStartVolumeSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::StartVolumeSyncResponse>> PrepareAsyncStartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::StartVolumeSyncResponse>>(PrepareAsyncStartVolumeSyncRaw(context, request, cq));
    }
    virtual ::grpc::Status FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::pos_rpc::FinishVolumeSyncResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::FinishVolumeSyncResponse>> AsyncFinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::FinishVolumeSyncResponse>>(AsyncFinishVolumeSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::FinishVolumeSyncResponse>> PrepareAsyncFinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::FinishVolumeSyncResponse>>(PrepareAsyncFinishVolumeSyncRaw(context, request, cq));
    }
    virtual ::grpc::Status SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::pos_rpc::SuspendWriteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::SuspendWriteResponse>> AsyncSuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::SuspendWriteResponse>>(AsyncSuspendWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::SuspendWriteResponse>> PrepareAsyncSuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::SuspendWriteResponse>>(PrepareAsyncSuspendWriteRaw(context, request, cq));
    }
    virtual ::grpc::Status ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::pos_rpc::ResumeWriteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ResumeWriteResponse>> AsyncResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ResumeWriteResponse>>(AsyncResumeWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ResumeWriteResponse>> PrepareAsyncResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ResumeWriteResponse>>(PrepareAsyncResumeWriteRaw(context, request, cq));
    }
    virtual ::grpc::Status ChangeReplicationRole(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest& request, ::pos_rpc::ChangeReplicationRoleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ChangeReplicationRoleResponse>> AsyncChangeReplicationRole(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ChangeReplicationRoleResponse>>(AsyncChangeReplicationRoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ChangeReplicationRoleResponse>> PrepareAsyncChangeReplicationRole(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ChangeReplicationRoleResponse>>(PrepareAsyncChangeReplicationRoleRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ChangeReplicationRole(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest* request, ::pos_rpc::ChangeReplicationRoleResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ChangeReplicationRole(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest* request, ::pos_rpc::ChangeReplicationRoleResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ChangeReplicationRole(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest* request, ::pos_rpc::ChangeReplicationRoleResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::StartVolumeSyncResponse>* AsyncStartVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::StartVolumeSyncResponse>* PrepareAsyncStartVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::FinishVolumeSyncResponse>* AsyncFinishVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::FinishVolumeSyncResponse>* PrepareAsyncFinishVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::SuspendWriteResponse>* AsyncSuspendWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::SuspendWriteResponse>* PrepareAsyncSuspendWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ResumeWriteResponse>* AsyncResumeWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ResumeWriteResponse>* PrepareAsyncResumeWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ChangeReplicationRoleResponse>* AsyncChangeReplicationRoleRaw(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::pos_rpc::ChangeReplicationRoleResponse>* PrepareAsyncChangeReplicationRoleRaw(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::pos_rpc::StartVolumeSyncResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::StartVolumeSyncResponse>> AsyncStartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::StartVolumeSyncResponse>>(AsyncStartVolumeSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::StartVolumeSyncResponse>> PrepareAsyncStartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::StartVolumeSyncResponse>>(PrepareAsyncStartVolumeSyncRaw(context, request, cq));
    }
    ::grpc::Status FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::pos_rpc::FinishVolumeSyncResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::FinishVolumeSyncResponse>> AsyncFinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::FinishVolumeSyncResponse>>(AsyncFinishVolumeSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::FinishVolumeSyncResponse>> PrepareAsyncFinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::FinishVolumeSyncResponse>>(PrepareAsyncFinishVolumeSyncRaw(context, request, cq));
    }
    ::grpc::Status SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::pos_rpc::SuspendWriteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::SuspendWriteResponse>> AsyncSuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::SuspendWriteResponse>>(AsyncSuspendWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::SuspendWriteResponse>> PrepareAsyncSuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::SuspendWriteResponse>>(PrepareAsyncSuspendWriteRaw(context, request, cq));
    }
    ::grpc::Status ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::pos_rpc::ResumeWriteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ResumeWriteResponse>> AsyncResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ResumeWriteResponse>>(AsyncResumeWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ResumeWriteResponse>> PrepareAsyncResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ResumeWriteResponse>>(PrepareAsyncResumeWriteRaw(context, request, cq));
    }
    ::grpc::Status ChangeReplicationRole(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest& request, ::pos_rpc::ChangeReplicationRoleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ChangeReplicationRoleResponse>> AsyncChangeReplicationRole(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ChangeReplicationRoleResponse>>(AsyncChangeReplicationRoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ChangeReplicationRoleResponse>> PrepareAsyncChangeReplicationRole(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::pos_rpc::ChangeReplicationRoleResponse>>(PrepareAsyncChangeReplicationRoleRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StartVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FinishVolumeSync(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SuspendWrite(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ResumeWrite(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ChangeReplicationRole(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest* request, ::pos_rpc::ChangeReplicationRoleResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ChangeReplicationRole(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest* request, ::pos_rpc::ChangeReplicationRoleResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ChangeReplicationRole(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest* request, ::pos_rpc::ChangeReplicationRoleResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::StartVolumeSyncResponse>* AsyncStartVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::StartVolumeSyncResponse>* PrepareAsyncStartVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::StartVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::FinishVolumeSyncResponse>* AsyncFinishVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::FinishVolumeSyncResponse>* PrepareAsyncFinishVolumeSyncRaw(::grpc::ClientContext* context, const ::pos_rpc::FinishVolumeSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::SuspendWriteResponse>* AsyncSuspendWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::SuspendWriteResponse>* PrepareAsyncSuspendWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::SuspendWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ResumeWriteResponse>* AsyncResumeWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ResumeWriteResponse>* PrepareAsyncResumeWriteRaw(::grpc::ClientContext* context, const ::pos_rpc::ResumeWriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ChangeReplicationRoleResponse>* AsyncChangeReplicationRoleRaw(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::pos_rpc::ChangeReplicationRoleResponse>* PrepareAsyncChangeReplicationRoleRaw(::grpc::ClientContext* context, const ::pos_rpc::ChangeReplicationRoleRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_StartVolumeSync_;
    const ::grpc::internal::RpcMethod rpcmethod_FinishVolumeSync_;
    const ::grpc::internal::RpcMethod rpcmethod_SuspendWrite_;
    const ::grpc::internal::RpcMethod rpcmethod_ResumeWrite_;
    const ::grpc::internal::RpcMethod rpcmethod_ChangeReplicationRole_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status StartVolumeSync(::grpc::ServerContext* context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response);
    virtual ::grpc::Status FinishVolumeSync(::grpc::ServerContext* context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response);
    virtual ::grpc::Status SuspendWrite(::grpc::ServerContext* context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response);
    virtual ::grpc::Status ResumeWrite(::grpc::ServerContext* context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response);
    virtual ::grpc::Status ChangeReplicationRole(::grpc::ServerContext* context, const ::pos_rpc::ChangeReplicationRoleRequest* request, ::pos_rpc::ChangeReplicationRoleResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_StartVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartVolumeSync() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_StartVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartVolumeSync(::grpc::ServerContext* context, ::pos_rpc::StartVolumeSyncRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::StartVolumeSyncResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FinishVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FinishVolumeSync() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_FinishVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FinishVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFinishVolumeSync(::grpc::ServerContext* context, ::pos_rpc::FinishVolumeSyncRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::FinishVolumeSyncResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SuspendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SuspendWrite() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SuspendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SuspendWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSuspendWrite(::grpc::ServerContext* context, ::pos_rpc::SuspendWriteRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::SuspendWriteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResumeWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResumeWrite() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ResumeWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResumeWrite(::grpc::ServerContext* context, ::pos_rpc::ResumeWriteRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::ResumeWriteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChangeReplicationRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChangeReplicationRole() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ChangeReplicationRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeReplicationRole(::grpc::ServerContext* /*context*/, const ::pos_rpc::ChangeReplicationRoleRequest* /*request*/, ::pos_rpc::ChangeReplicationRoleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChangeReplicationRole(::grpc::ServerContext* context, ::pos_rpc::ChangeReplicationRoleRequest* request, ::grpc::ServerAsyncResponseWriter< ::pos_rpc::ChangeReplicationRoleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_StartVolumeSync<WithAsyncMethod_FinishVolumeSync<WithAsyncMethod_SuspendWrite<WithAsyncMethod_ResumeWrite<WithAsyncMethod_ChangeReplicationRole<Service > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StartVolumeSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::StartVolumeSyncRequest, ::pos_rpc::StartVolumeSyncResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::StartVolumeSyncRequest* request, ::pos_rpc::StartVolumeSyncResponse* response) { return this->StartVolumeSync(context, request, response); }));}
    void SetMessageAllocatorFor_StartVolumeSync(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::StartVolumeSyncRequest, ::pos_rpc::StartVolumeSyncResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::StartVolumeSyncRequest, ::pos_rpc::StartVolumeSyncResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StartVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StartVolumeSync(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StartVolumeSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FinishVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FinishVolumeSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::FinishVolumeSyncRequest, ::pos_rpc::FinishVolumeSyncResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::FinishVolumeSyncRequest* request, ::pos_rpc::FinishVolumeSyncResponse* response) { return this->FinishVolumeSync(context, request, response); }));}
    void SetMessageAllocatorFor_FinishVolumeSync(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::FinishVolumeSyncRequest, ::pos_rpc::FinishVolumeSyncResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::FinishVolumeSyncRequest, ::pos_rpc::FinishVolumeSyncResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FinishVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FinishVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FinishVolumeSync(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FinishVolumeSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SuspendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SuspendWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::SuspendWriteRequest, ::pos_rpc::SuspendWriteResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::SuspendWriteRequest* request, ::pos_rpc::SuspendWriteResponse* response) { return this->SuspendWrite(context, request, response); }));}
    void SetMessageAllocatorFor_SuspendWrite(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::SuspendWriteRequest, ::pos_rpc::SuspendWriteResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::SuspendWriteRequest, ::pos_rpc::SuspendWriteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SuspendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SuspendWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SuspendWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SuspendWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ResumeWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ResumeWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::ResumeWriteRequest, ::pos_rpc::ResumeWriteResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::ResumeWriteRequest* request, ::pos_rpc::ResumeWriteResponse* response) { return this->ResumeWrite(context, request, response); }));}
    void SetMessageAllocatorFor_ResumeWrite(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::ResumeWriteRequest, ::pos_rpc::ResumeWriteResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::ResumeWriteRequest, ::pos_rpc::ResumeWriteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ResumeWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ResumeWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ResumeWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ChangeReplicationRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ChangeReplicationRole() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::pos_rpc::ChangeReplicationRoleRequest, ::pos_rpc::ChangeReplicationRoleResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::pos_rpc::ChangeReplicationRoleRequest* request, ::pos_rpc::ChangeReplicationRoleResponse* response) { return this->ChangeReplicationRole(context, request, response); }));}
    void SetMessageAllocatorFor_ChangeReplicationRole(
        ::grpc::experimental::MessageAllocator< ::pos_rpc::ChangeReplicationRoleRequest, ::pos_rpc::ChangeReplicationRoleResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::pos_rpc::ChangeReplicationRoleRequest, ::pos_rpc::ChangeReplicationRoleResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ChangeReplicationRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeReplicationRole(::grpc::ServerContext* /*context*/, const ::pos_rpc::ChangeReplicationRoleRequest* /*request*/, ::pos_rpc::ChangeReplicationRoleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ChangeReplicationRole(
      ::grpc::CallbackServerContext* /*context*/, const ::pos_rpc::ChangeReplicationRoleRequest* /*request*/, ::pos_rpc::ChangeReplicationRoleResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ChangeReplicationRole(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::pos_rpc::ChangeReplicationRoleRequest* /*request*/, ::pos_rpc::ChangeReplicationRoleResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_StartVolumeSync<ExperimentalWithCallbackMethod_FinishVolumeSync<ExperimentalWithCallbackMethod_SuspendWrite<ExperimentalWithCallbackMethod_ResumeWrite<ExperimentalWithCallbackMethod_ChangeReplicationRole<Service > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_StartVolumeSync<ExperimentalWithCallbackMethod_FinishVolumeSync<ExperimentalWithCallbackMethod_SuspendWrite<ExperimentalWithCallbackMethod_ResumeWrite<ExperimentalWithCallbackMethod_ChangeReplicationRole<Service > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_StartVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartVolumeSync() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_StartVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FinishVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FinishVolumeSync() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_FinishVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FinishVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SuspendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SuspendWrite() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SuspendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SuspendWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResumeWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResumeWrite() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ResumeWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChangeReplicationRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChangeReplicationRole() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ChangeReplicationRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeReplicationRole(::grpc::ServerContext* /*context*/, const ::pos_rpc::ChangeReplicationRoleRequest* /*request*/, ::pos_rpc::ChangeReplicationRoleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartVolumeSync() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_StartVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartVolumeSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FinishVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FinishVolumeSync() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_FinishVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FinishVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFinishVolumeSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SuspendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SuspendWrite() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SuspendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SuspendWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSuspendWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResumeWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResumeWrite() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ResumeWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResumeWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChangeReplicationRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChangeReplicationRole() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ChangeReplicationRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeReplicationRole(::grpc::ServerContext* /*context*/, const ::pos_rpc::ChangeReplicationRoleRequest* /*request*/, ::pos_rpc::ChangeReplicationRoleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChangeReplicationRole(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StartVolumeSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartVolumeSync(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_StartVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StartVolumeSync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StartVolumeSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FinishVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FinishVolumeSync() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FinishVolumeSync(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FinishVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FinishVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FinishVolumeSync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FinishVolumeSync(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SuspendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SuspendWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SuspendWrite(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SuspendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SuspendWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SuspendWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SuspendWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ResumeWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ResumeWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResumeWrite(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ResumeWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ResumeWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ResumeWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ChangeReplicationRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ChangeReplicationRole() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ChangeReplicationRole(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ChangeReplicationRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeReplicationRole(::grpc::ServerContext* /*context*/, const ::pos_rpc::ChangeReplicationRoleRequest* /*request*/, ::pos_rpc::ChangeReplicationRoleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ChangeReplicationRole(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ChangeReplicationRole(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartVolumeSync() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::StartVolumeSyncRequest, ::pos_rpc::StartVolumeSyncResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::StartVolumeSyncRequest, ::pos_rpc::StartVolumeSyncResponse>* streamer) {
                       return this->StreamedStartVolumeSync(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::StartVolumeSyncRequest* /*request*/, ::pos_rpc::StartVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartVolumeSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::StartVolumeSyncRequest,::pos_rpc::StartVolumeSyncResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FinishVolumeSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FinishVolumeSync() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::FinishVolumeSyncRequest, ::pos_rpc::FinishVolumeSyncResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::FinishVolumeSyncRequest, ::pos_rpc::FinishVolumeSyncResponse>* streamer) {
                       return this->StreamedFinishVolumeSync(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FinishVolumeSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FinishVolumeSync(::grpc::ServerContext* /*context*/, const ::pos_rpc::FinishVolumeSyncRequest* /*request*/, ::pos_rpc::FinishVolumeSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFinishVolumeSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::FinishVolumeSyncRequest,::pos_rpc::FinishVolumeSyncResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SuspendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SuspendWrite() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::SuspendWriteRequest, ::pos_rpc::SuspendWriteResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::SuspendWriteRequest, ::pos_rpc::SuspendWriteResponse>* streamer) {
                       return this->StreamedSuspendWrite(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SuspendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SuspendWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::SuspendWriteRequest* /*request*/, ::pos_rpc::SuspendWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSuspendWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::SuspendWriteRequest,::pos_rpc::SuspendWriteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResumeWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResumeWrite() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::ResumeWriteRequest, ::pos_rpc::ResumeWriteResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::ResumeWriteRequest, ::pos_rpc::ResumeWriteResponse>* streamer) {
                       return this->StreamedResumeWrite(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResumeWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResumeWrite(::grpc::ServerContext* /*context*/, const ::pos_rpc::ResumeWriteRequest* /*request*/, ::pos_rpc::ResumeWriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResumeWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::ResumeWriteRequest,::pos_rpc::ResumeWriteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChangeReplicationRole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ChangeReplicationRole() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::pos_rpc::ChangeReplicationRoleRequest, ::pos_rpc::ChangeReplicationRoleResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::pos_rpc::ChangeReplicationRoleRequest, ::pos_rpc::ChangeReplicationRoleResponse>* streamer) {
                       return this->StreamedChangeReplicationRole(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ChangeReplicationRole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChangeReplicationRole(::grpc::ServerContext* /*context*/, const ::pos_rpc::ChangeReplicationRoleRequest* /*request*/, ::pos_rpc::ChangeReplicationRoleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChangeReplicationRole(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::pos_rpc::ChangeReplicationRoleRequest,::pos_rpc::ChangeReplicationRoleResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_StartVolumeSync<WithStreamedUnaryMethod_FinishVolumeSync<WithStreamedUnaryMethod_SuspendWrite<WithStreamedUnaryMethod_ResumeWrite<WithStreamedUnaryMethod_ChangeReplicationRole<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_StartVolumeSync<WithStreamedUnaryMethod_FinishVolumeSync<WithStreamedUnaryMethod_SuspendWrite<WithStreamedUnaryMethod_ResumeWrite<WithStreamedUnaryMethod_ChangeReplicationRole<Service > > > > > StreamedService;
};

}  // namespace pos_rpc


#endif  // GRPC_pos_5frpc_2eproto__INCLUDED
